//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

@class MISSING_TYPE, SCNNode, UIGestureRecognizer;

@interface SCNCameraControlEventHandler
{
    SCNNode *_freeViewCameraNode;	// 24 = 0x18
    struct CGPoint _initialPoint;	// 32 = 0x20
    union C3DMatrix4x4 _initialMatrix;	// 48 = 0x30
    float _initialZoom;	// 112 = 0x70
    float _originalFovX;	// 116 = 0x74
    float _originalFovY;	// 120 = 0x78
    float _originalOrthoScale;	// 124 = 0x7c
    float _zoomFactor;	// 128 = 0x80
    MISSING_TYPE *_clickOrigin;	// 144 = 0x90
    int _lastGestureFingerCount;	// 160 = 0xa0
    _Bool _isDraggingWithOneFinger;	// 164 = 0xa4
    float _roll;	// 168 = 0xa8
    union C3DMatrix4x4 _initialMatrixForRoll;	// 176 = 0xb0
    UIGestureRecognizer *_pressGesture;	// 240 = 0xf0
    UIGestureRecognizer *_tapGesture;	// 248 = 0xf8
    UIGestureRecognizer *_pinchGesture;	// 256 = 0x100
    UIGestureRecognizer *_panGesture;	// 264 = 0x108
    UIGestureRecognizer *_rotateGesture;	// 272 = 0x110
    unsigned long long _stickyAxis;	// 280 = 0x118
    struct C3DSphere _viewedObjectSphere;	// 288 = 0x120
    unsigned int _isViewedObjectSphereComputed:1;	// 304 = 0x130
    struct os_unfair_lock_s _stateLock;	// 308 = 0x134
    unsigned int _enabled:1;	// 312 = 0x138
    unsigned int _hasAutomaticCameraTarget:1;	// 312 = 0x138
    unsigned int _automaticCameraTargetUpToDate:1;	// 312 = 0x138
    unsigned int _inertia:1;	// 312 = 0x138
    unsigned int _didEverFocusNode:1;	// 312 = 0x138
    unsigned int _allowsTranslation:1;	// 312 = 0x138
    unsigned int _pinchShouldMoveCamera:1;	// 312 = 0x138
    unsigned int _alternateMode:1;	// 312 = 0x138
    unsigned int _upDirIsSet:1;	// 313 = 0x139
    unsigned int _gimbalLockMode:1;	// 313 = 0x139
    unsigned int _inertiaRunning:1;	// 313 = 0x139
    long long _browseMode;	// 320 = 0x140
    MISSING_TYPE *_upDir;	// 336 = 0x150
    struct SCNVector3 _cameraTarget;	// 352 = 0x160
    struct SCNVector3 _autoCameraTarget;	// 364 = 0x16c
    float _browseScaleFactor;	// 376 = 0x178
    double _friction;	// 384 = 0x180
    struct CGPoint _totalDragWithInertia;	// 392 = 0x188
    struct CGPoint _inertiaVelocity;	// 408 = 0x198
    double _lastSimulationTime;	// 424 = 0x1a8
}

+ (struct SCNMatrix4)matrixWithNoRoll:(struct SCNMatrix4)arg1;	// IMP=0x000000000029188a
+ (MISSING_TYPE *)frontVectorWithPointOfView:(id)arg1;	// IMP=0x0000000000291555
- (void)panWithGestureRecognizer:(id)arg1;	// IMP=0x0000000000292cba
- (void)pinchWithGestureRecognizer:(id)arg1;	// IMP=0x0000000000292c63
- (void)rotateWithGestureRecognizer:(id)arg1;	// IMP=0x0000000000292b6b
- (void)beginGesture:(id)arg1;	// IMP=0x0000000000292953
- (void)_handlePress:(id)arg1;	// IMP=0x000000000029294d
- (void)_handleDoubleTap:(id)arg1;	// IMP=0x000000000029290e
- (void)_handleRotation:(id)arg1;	// IMP=0x00000000002928ed
- (void)_handlePan:(id)arg1;	// IMP=0x00000000002928cc
- (void)_handlePinch:(id)arg1;	// IMP=0x00000000002928ab
- (_Bool)gestureRecognizerShouldBegin:(id)arg1;	// IMP=0x0000000000292896
- (id)gestureRecognizers;	// IMP=0x0000000000292559
- (_Bool)gestureRecognizer:(id)arg1 shouldRecognizeSimultaneouslyWithGestureRecognizer:(id)arg2;	// IMP=0x00000000002924e2
- (void)_translateTo:(struct CGPoint)arg1;	// IMP=0x0000000000292194
- (void)_rotateWithDrag:(struct CGPoint)arg1 mode:(long long)arg2 stickyAxis:(unsigned long long)arg3;	// IMP=0x0000000000291c34
- (void)clearRoll;	// IMP=0x0000000000291ad2
- (void)_beginTranslateAtLocation:(struct CGPoint)arg1;	// IMP=0x0000000000291669
- (MISSING_TYPE *)frontVector;	// IMP=0x000000000029160a
- (struct C3DSphere)viewedObjectSphere;	// IMP=0x00000000002913bf
- (_Bool)computeBoundingSphereOmittingFloorsForNode:(struct __C3DNode *)arg1 sphere:(struct C3DSphere *)arg2;	// IMP=0x00000000002912d5
- (void)_startBrowsingIfNeeded:(struct CGPoint)arg1;	// IMP=0x00000000002910a5
- (void)endDraggingWithVelocity:(struct CGPoint)arg1;	// IMP=0x0000000000290fb5
- (_Bool)wantsRedraw;	// IMP=0x0000000000290f7c
- (_Bool)_3DConnexionIsPressed;	// IMP=0x0000000000290f74
- (_Bool)_isInertiaRunning;	// IMP=0x0000000000290f2f
- (void)_setInertiaRunning:(_Bool)arg1;	// IMP=0x0000000000290ee2
- (void)viewWillDrawAtTime:(double)arg1;	// IMP=0x0000000000290eab
- (void)rotateWithVector:(long long)arg1 mode: /* Error: Ran out of types for this method. */;	// IMP=0x0000000000290db9
- (void)_onInertiaTimer;	// IMP=0x0000000000290c46
- (void)cameraDidChange;	// IMP=0x0000000000290c18
- (void)cameraWillChange;	// IMP=0x0000000000290bf9
- (void)sceneDidChange;	// IMP=0x0000000000290bcb
- (void)sceneWillChange;	// IMP=0x0000000000290b85
- (void)translateByX:(float)arg1 Y:(float)arg2 Z:(float)arg3;	// IMP=0x0000000000290922
- (void)setZoomFactor:(double)arg1;	// IMP=0x0000000000290561
- (double)zoomFactor;	// IMP=0x000000000029054f
- (void)zoomBy:(float)arg1;	// IMP=0x0000000000290538
- (void)zoomBy:(float)arg1 animate:(_Bool)arg2;	// IMP=0x0000000000290378
- (void)rotateOf:(double)arg1;	// IMP=0x0000000000290254
- (void)updateBrowseScaleFactor;	// IMP=0x00000000002900df
- (void)_resetBrowseScaleFactor;	// IMP=0x0000000000290023
- (double)_browseScale;	// IMP=0x0000000000290011
- (float)_translationCoef;	// IMP=0x000000000028fff2
- (void)computeAutomaticTargetPoint;	// IMP=0x000000000028fe98
- (struct SCNVector3)cameraAutomaticTargetPoint;	// IMP=0x000000000028fe59
- (void)_switchToFreeViewCamera;	// IMP=0x000000000028fdc6
- (void)_installFreeViewCameraIfNeeded;	// IMP=0x000000000028fcf9
- (void)_prepareFreeViewCamera;	// IMP=0x000000000028f754
- (_Bool)_freeCameraActivated;	// IMP=0x000000000028f703
- (void)_resetFreeViewCamera;	// IMP=0x000000000028f673
- (void)activateFreeCamera;	// IMP=0x000000000028f632
- (void)setEnableFreeCamera:(_Bool)arg1;	// IMP=0x000000000028f617
@property unsigned long long stickyAxis;
- (void)focusNode:(id)arg1;	// IMP=0x000000000028f339
- (id)freeCamera;	// IMP=0x000000000028f328
@property struct SCNVector3 cameraTarget;
@property _Bool automaticCameraTarget;
- (void)invalidateCameraTarget;	// IMP=0x000000000028f2b6
@property struct SCNVector3 gimbalLockVector;
@property _Bool gimbalLockMode;
@property double friction;
@property _Bool enableInertia;
@property _Bool allowsTranslation;
- (void)setEnabled:(_Bool)arg1;	// IMP=0x000000000028f08e
- (_Bool)enabled;	// IMP=0x000000000028f07c
- (void)dealloc;	// IMP=0x000000000028efdb
- (id)init;	// IMP=0x000000000028ef3f

@end

